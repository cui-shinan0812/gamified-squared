# Gamified Square Hand-Over

## Preparation


Unity Editor ver. 2022.3.35f1 <br>
Visual Studio (Community) 2022 ver.17.10.4

- install all components related to C++ (can ignore Linux one if not developing under Linux).
![alt text](PorjectPreparationComponents.png)

<hr>

### Use of Dll

#### Install

Put the dll under "**Assets\Plugins**" folder.

Import this libraray in every class that calls dll functions
```CS
using System.Runtime.InteropServices;
```

Example of declaring a dll function in C#
```CS
[DllImport("libUnityPlugIn")]
private static extern void displayFrameUnity(IntPtr frame);
```
It's fine to seperate dlls with folders under **Plugins folder**. The name inside "DllImport()" don't need to be changed.
![alt text](dllDirectory.png)

Remember to include header file to support dll usage. Just like dll, put them under the directory you like as long as they are under **Assets folder**.
![alt text](headerDirectory.png)

> **Caution**: Includes all four header files, **framework**, **hardwareapi**, **middleWaredll** and **pch**. **hardwareapi** and **middleWaredll** is developed by developer while **framework** and **pch** is generated by Visual Studio.

>**Note**: "**[DllImport("libUnityPlugIn")]**" must be set above every function declaration. ".dll" at the extension can be omitted.
Example:
```CS
[DllImport("libUnityPlugIn")]
private static extern void displayFrameUnity(IntPtr frame);
[DllImport("libUnityPlugIn", CallingConvention = CallingConvention.Cdecl)]
public static extern IntPtr getSensors(IntPtr hardwareMatrix);
```

<hr>

### Use of Config

Some data from the config file is stored in the **Player Prefernce** when every time **DllInitiater** runs Start() to allow them being access across scene.

```CS
// Usage
// Set in DllInitiater
PlayerPrefs.SetInt(HEIGHT, M);
PlayerPrefs.SetInt(WIDTH, N);
PlayerPrefs.SetInt(NUM_OF_PORTS, NumOfPorts);
PlayerPrefs.SetInt(MAX_LENGTH, MaxLength);
PlayerPrefs.SetInt(CONTROLLER_USED, ControllerUsed);

//Get in other scripts
M = PlayerPrefs.GetInt(DllInitiater.HEIGHT);
N = PlayerPrefs.GetInt(DllInitiater.WIDTH);
NumOfPorts = PlayerPrefs.GetInt(DllInitiater.NUM_OF_PORTS);
MAX_LENGTH = PlayerPrefs.GetInt(DllInitiater.MAX_LENGTH);
CONTROLLER_USED = PlayerPrefs.GetInt(DllInitiater.CONTROLLER_USED);
```

<hr>

## Game Structure
This document will explain the project scene by scene.
Essential Scenes for constructing the game are:
 - MainMenu
	 > Simple main page with 2 buttons. 1 navigate to Mode scene and 1 call up settings UI.
	 
 - Mode
	 > Perform navigation to Rule Scene by clicking on 1 of the 3 islands. Currently only the forest 1 (Game mode C) is functional.

 - Rule
	 > Perform navigation to Map Scene and telling the player the rule of the game mode.

 - Maps
	 > Perform navigation to Gameplay Scene. The map selection is not functional. The options are just mere displays under current state.

 - GameplayPathMem
	 > Perform actual game logic of the game.

> **Note:** Other scenes that are not metioned above are mainly for testing purpose. 

### MainMenu

 - Canvas
	 > containing UIs.
	 
	 * BackgroundRawImage
		 > Display Background Image. Click texture field to replace the displaying image on the inspector panel.
		 ![alt text](BgImgChange.png)
	 * GameTitleRawImage
		 > Display Game Title Image. Click **texture** field to replace the displaying image on the inspector panel.

	 * MainMenuUI
		 > Display the 2 buttons that call up or navigate to other UI pages. Attached the **MainMenuUIDesignVer2 C# script**. 
		 
	 * SettingsUI
		 > Responsible to the tuning of both music and sfx volume. Attached the **GameSettingsUIDesignVer2 C# script**. 

 - EventSystem
	> Auto generated by Unity. **Do not remove** this game object.

 - FileManager
	> FileManager is responsible to any function that require file access like opening file browser. It attached **FileManager C# script**.

- MusicManager 
	> MusicManager is responsible to the volume control of any music. Only background music for this project. It attached **MusicManager C# script** and **DoNotDestroyManager C# script**. **DoNotDestroyManager** helps perform seamless music plays cross scene

 - SoundManager
	> SoundManager is responsible to the volume control of any sfx. Only button clicking sfx for this project. It associates with **AudioClipRefsSO** which is a Scriptable Object responsible to store the audio clips we want to play. It attached **SoundManager C# script**.

 - DllInitiater
	> DllInitiater is used to trigger the init() function in the dll, which is responsible to send the config data to the hardware. It attached **DllInitiater C# script**.

 - JsonManager
	> JsonManager responsible on Json file handling. It attached **JsonManager C# script**.

### About

 - Canvas
	 > containig background image and title only.
	 
### Mode

 - Canvas
	 > containig background image and three (only forest 1 is functional) interactive game object.

	* Forest
		> Using **Event Trigger** and attaching **SceneManager C# script** for changing scene. 
	 
### Rule

 - Canvas
	 > containig background image and a button to navigate to Maps scene.

### Maps

 - Canvas
	 > containig background image (fake) options which is to perform map selection.

### GameplayPathMem

 - Canvas
	 > containig background image and UIs.

	* GamePlayingClockUI
		 > Display the round-shaped timer of the game. It attached **GamePlayingClockUI C# script**.

	* GameStartCountdownUI 
		 > Display the count down number **before** starting the game. It attached **GameStartCountdownUI C# script**.

	* GameCorrectCountDisplayUI
		 > Display the number of **correctly** steps grids **during** the game. It attached **GameCorrectStepsCountUI C# script**.

	* ScoreBoardUI
		 > Display the score board when **GAME OVER**. It attached **ScoreBoardUI C# script**.

 - GameplayPathMemManager
	 > This Gameplay Manager is created **specific for the Path Memorizing game**. This Manager responsible on the game logic handling. It calls **VirtualLedGridSO** C# script to handle the time gap between red-to-yellow light changing. It attached **GameplayPathMemManager C# script**.

 - FileManager
	 > ***#Refer to description in MainMenu session.***
	 
- RawImage * 2
	 > No practicle use. They are created just for fulfilling the gameobject reference coded in FileManager to prevent compilation error. **Do not remove** until you are not using FileManager in this scnen anymore. Always keep them **hidden**.
	 
 - DllManager
	 > DllManager is responsible on calling other functions from the dll. It attached **DllManager C# script**.

 - UDPManager
	 > UDPManager is responsible to receive and further process the received data from UDP message. It attached **UDPManager  C# script**.


### Legacy Scenes

- TestEditSceneDynamicGridSize
	> Test the function of edit mode with dynamic display. Abanddoned due to too user-unfriendly and displaying bug when printing high resolution arrays

- TestPathMemGameplay
	> Test the game logic. Since the script is modify to be used in real game, running this scene will only cause error.

- TestMainMenuScene
	> Test MainMenuUI and SettingsUI functions. also attached some dll tester. Some functions like in game changing backgound image can be referenced in this scene. Using **Legacy** C# script like **GameSettingsUI** and **MainMenuUI**

<hr>

## Structure of Code


The scripts directly related to the running of the game are:

* MainMenuUIDesignVer2 **(MainMenu)**
	> Called / Accessed by (Script): 
	**GameSettingsUIDesignVer2**

* GameSettingsUIDesignVer2 **(MainMenu)**
	> Called / Accessed by (Script): **None**

* FileManager **(MainMenu, GameplayPathMem)**
	> Called / Accessed by (Script): **GameplayPathMemManager**

* MusicManager **(MainMenu)**
	> Called / Accessed by (Script): **GameSettingsUIDesignVer2**

* DoNotDestroyManager **(MainMenu)**
	> Called / Accessed by (Script): **None**

* AudioClipRefsSO **(MainMenu)**
	> Called / Accessed by (Script): **SoundManager** 
	
* SoundManager **(MainMenu)**
	> Called / Accessed by (Script): **GameSettingsUIDesignVer2**

* DllInitiater **(MainMenu)**
	> Called / Accessed by (Script): **UDPManager** 

* JsonManager **(MainMenu)**
	> Called / Accessed by (Script): **DllInitiater**

* SceneManager **(MainMenu, About, Mode, Rule, Maps, GameplayPathMem)**
	> Called / Accessed by (Script): **None**

* GamePlayingClockUI **(GameplayPathMem)**
	> Called / Accessed by (Script): **None**

* GameStartCountdownUI **(GameplayPathMem)**
	> Called / Accessed by (Script): **None**

* GameCorrectStepsCountUI **(GameplayPathMem)**
	> Called / Accessed by (Script): **None**

* ScoreBoardUI **(GameplayPathMem)**
	> Called / Accessed by (Script): **None**

* GameplayPathMemManager **(GameplayPathMem)**
	> Called / Accessed by (Script): **GameStartCountdownUI, GamePlayingClockUI, ScoreBoardUI, GameStartCountdownUI**

* VirtualLedGridSO **(GameplayPathMem)**
	> Called / Accessed by (Script): **GameplayPathMemManager**

* DllManager **(GameplayPathMem)**
	> Called / Accessed by (Script): **UDPManager, GameplayPathMemManager**

* UDPManager **(GameplayPathMem)**
	> Called / Accessed by (Script): **None**

<hr>

## Game Logic (Path Memorizing)

This game need players to memorize the **corret path** and their **appearing sequance** when the game is counting down.

After Count down to 0, the game actually starting. Players need to steps out the correct path within **60** seconds. If players step on the **correct grid with the correct sequance**, the stepped grid turns **blue**, + 1 to correct step count and + 1 second on timer. If stepping on a **wrong grid or the correct grid but not in correct sequance**,  the stepped grid turn **red** first and -0.5 second on timer. Any **red** grid will turn **yellow** after 1 second passwd. 

Stepping on blue or red grid performs nothing (no penalty or reward).

 When timer reach 0 or all correct grids is stepped according to the sequence, the game enter GAME OVER state and display a score board to display the final score of the player.

The formula of the score counting:
```CS
int correctStepsScore = 100 * stepCorrectCount;  
int timeRemainBonus = 50 * Mathf.CeilToInt(gamePlayingTimer);  
gameTotalScore = correctStepsScore + timeRemainBonus;
```
> **Noted:** Code located at **GameplayPathMemManager.ConcludeResult()**

<hr>

### Logic Modifying

Game logic is fully handle by **GameplayPathMemManager**.

```CS
private float countdownToStartTimerMax = 5f; // seconds  
...
private float gamePlayingTimerMax = 60f; // seconds
```
Change these two fields to mdify defalut countdown time and gameplay time.

```CS
//SteppingHandle()
case EnumColor.BLUE:
	...
	gamePlayingTimer += 1f;
	...
	break;
```
Change the value to modify the reward value.

```CS
//SteppingHandle()
case EnumColor.OFF:
	...
	gamePlayingTimer -= .5f;
	...
	break;
```
Change the value to modify the penalty value.

```CS
//Update()
case State.CountdownToStart:
	countdownToStartTimer -= Time.deltaTime;  
	int countdownNumber = Mathf.CeilToInt(countdownToStartTimer);
	
	if (previousCountdownNumber != countdownNumber)
	{
	...
	}
	...
	break;
```
In CONTDOWNTOSTART state, this "if" statement make the game update the LED tiles every seconed. Which means when counting down, the game display 1 frame of the answer map only when a second is passed.

```CS
//Update()
case State.GamePlay	:
	gamePlayingTimer -= Time.deltaTime;  
  
	int gameplayNumber = Mathf.CeilToInt(gamePlayingTimer);  
	//DisplayPlayerViewMap();  
	DllManager.Instance.DisplayFrame(playerViewMap, m, n);  
	  
	// VVV comment this when not connect to hardware VVV  
	  
	steppedMap = UDPManager.Instance.GetTempStepMap();  
	  
	// ^^^ comment this when not connect to hardware ^^^  
	  
	ColorChangeTimeControl();  
	if (previousGameplayTimeNumber != gameplayNumber)  
	{  
	  if (gamePlayingTimer >= 0)  
	 {  // testing method calls. Their function conflict to each others, choose only one to active at a time  
	 // RandomStep(); // FixedStep();  Debug.Log("[System] Correct step: " + stepCorrectCount);  
	 }  previousGameplayTimeNumber = gameplayNumber;  
	}  
	SteppingHandle();  
	  
	if (gamePlayingTimer < 0f || stepCorrectCount == answerMap.Length)  
	{  
	  state = State.GameOver;  
	  OnStateChanged?.Invoke(this, EventArgs.Empty);  
	}  
	  
	break;
```
The Logic is similar in GAMEPLAY state. Anything outside of "if  (previousGameplayTimeNumber != gameplayNumber)" is updated every frame, which is the fastest update frequency.

So if any thing you want needed to be updated every second, put them into the "if" statement.

<hr>

## Json Structure
We have 3 kinds of json file to read:
1. config.json -- containing the hardware config
2. map.json -- containg the game map (int array) only
3. metaFile.json -- containg game map and other map information like map Name, difficulty, etc..

Scripts like **JsonManager** and **MetaFileManager** is responsible to extract data from specific json file.

<hr>

## Build Instruction

In the Unity Editor, on the **top tool bar**, goes to "**File -> Build Settings**".

Check **Only the scene you want** to be built in the actual game. Make sure the **MainMenu** is at **index 0** since this will be the page display to player first when this game is launched.
![alt text](buildGuideSceneToBeBuilt.png)

Finally, click **Build** button at the right corner of the Build Settings panel.

>**Note:** Make sure all Codes calling **EditorUtility** are either commented or removed. Otherwise, compilation error will occur which evenctually failing the build.
> ```CS
>// vvv comment the line before build. vvv
>// string path = EditorUtility.OpenFilePanel("Select JSON file", "", "json");  
>// ^^^ comment the line before build. ^^^
> string path = "Assets\\Resources\\config.json";
> ```
> Example form **JsonManager**.

>**Caution:** After building the game, need to manually add the files with the directory back to the game folder.

![alt text](buildGuideCaution.png)
![alt text](buildGuideCaution_2.png)
